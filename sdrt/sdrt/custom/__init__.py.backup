"""Custom scripts and overrides for SDRT app.

Purchase Order customization: fetch items from Demande d'Achat (Material Request child table)
instead of Item master.

Purchase Receipt customization: handle budget line items properly when fetching from Purchase Orders.
"""

import json
from typing import List, Dict, Optional
import frappe
from frappe import _
from frappe.utils import flt

__all__ = [
    'get_multi_da_budget_lines', 
    'engage_budgets_for_po', 
    'disengage_budgets_for_po',
    'make_purchase_receipt_override',
    'ensure_budget_placeholder_item',
    'setup_budget_system'
]


@frappe.whitelist()
def setup_budget_system():
	"""Initialize the budget system with required items and configurations."""
	try:
		ensure_budget_placeholder_item()
		return {"status": "success", "message": "Budget system initialized successfully"}
	except Exception as e:
		frappe.log_error(f"Error setting up budget system: {e}")
		return {"status": "error", "message": str(e)}


def _collect_da_lines(material_request: str) -> List[Dict]:
	"""Collect raw lines from a single Material Request custom child table.

	Kept internal so we can reuse for multi-selection.
	"""
	mr = frappe.get_doc('Material Request', material_request)
	rows: List[Dict] = []
	
	# Get a valid UOM that exists in the system
	def get_valid_uom():
		preferred = ['Nos', 'Unit', 'Unité', 'PCE', 'Each']
		for uom in preferred:
			if frappe.db.exists('UOM', uom):
				return uom
		# Fallback to first UOM found
		return frappe.db.get_value('UOM', {}, 'name') or 'Nos'
	
	valid_uom = get_valid_uom()
	
	for r in mr.get('demande_dachat') or []:
		qty = flt(r.qte) if r.qte else 0
		unit_price = flt(r.pu) if r.pu else 0
		estimation = flt(getattr(r, 'estimation', 0))
		if not unit_price and estimation and qty:
			unit_price = estimation / qty
		rows.append({
			'code_analytique': r.code_analytique,
			'description': r.description or '',
			'qty': qty or 0,
			'rate': unit_price or 0,
			'uom': valid_uom,
			'schedule_date': getattr(mr, 'schedule_date', None) or getattr(mr, 'transaction_date', None)
		})
	return rows


def _aggregate_amounts(rows: List[Dict]) -> Dict[str, float]:
	"""Return aggregated amount (qty*rate) per budget code."""
	agg: Dict[str, float] = {}
	for r in rows:
		code = r.get('code_analytique')
		if not code:
			continue
		amt = flt(r.get('qty')) * flt(r.get('rate'))
		agg[code] = agg.get(code, 0) + amt
	return agg


def _validate_budget(purchase_order: Optional[str], new_rows: List[Dict]):
	"""Validate that adding new_rows won't exceed available budget.

	Rules:
	- For each code_analytique, compute existing draft PO amount (qty*rate for current items).
	- Sum new rows per code.
	- Compare (existing_draft + new_addition) <= available_amount field on SDR Budget.
	- If any exceed, raise frappe.ValidationError listing offending codes with remaining vs required.
	"""
	if not new_rows:
		return

	existing: dict[str, float] = {}
	if purchase_order:
		try:
			po = frappe.get_doc('Purchase Order', purchase_order)
			for it in po.get('items') or []:
				code = getattr(it, 'code_analytique', None)
				if not code:
					continue
				amt = flt(getattr(it, 'qty', 0)) * flt(getattr(it, 'rate', 0))
				existing[code] = existing.get(code, 0) + amt
		except Exception:
			pass  # If PO not found, ignore

	new_agg = _aggregate_amounts(new_rows)
	errors = []
	for code, add_amt in new_agg.items():
		try:
			bud = frappe.get_doc('SDR Budget', code)
		except frappe.DoesNotExistError:
			errors.append(_(f"Budget introuvable: {code}"))
			continue
		available = flt(getattr(bud, 'available_amount', 0))
		existing_amt = existing.get(code, 0)
		remaining_for_new = available - existing_amt
		if add_amt > remaining_for_new + 1e-9:  # tolerance
			errors.append(_(f"Code {code}: requis {add_amt:.2f} > disponible {remaining_for_new:.2f}"))

	if errors:
		frappe.throw('<br>'.join(errors), title=_('Dépassement budget'))


@frappe.whitelist()
def get_da_budget_lines(material_request: str, supplier: Optional[str] = None, purchase_order: Optional[str] = None):
	"""Single Material Request import with budget validation."""
	if not material_request:
		frappe.throw(_('Material Request manquant.'))
	rows = _collect_da_lines(material_request)
	_validate_budget(purchase_order, rows)
	return rows


@frappe.whitelist()
def get_multi_da_budget_lines(material_requests: str, supplier: Optional[str] = None, purchase_order: Optional[str] = None):
	"""Collect lines from multiple Material Requests and validate budgets.

	`material_requests` can be a JSON array string or comma separated names.
	"""
	if not material_requests:
		frappe.throw(_('Veuillez sélectionner au moins une Demande de Matériel.'))
	# Normalize input to list
	if isinstance(material_requests, str):
		try:
			if material_requests.strip().startswith('['):
				mr_list = json.loads(material_requests)
			else:
				mr_list = [m.strip() for m in material_requests.split(',') if m.strip()]
		except Exception:
			frappe.throw(_('Format invalide pour material_requests'))
	else:
		mr_list = material_requests

	all_rows: List[Dict] = []
	for mr in mr_list:
		all_rows.extend(_collect_da_lines(mr))

	_validate_budget(purchase_order, all_rows)
	return all_rows


def _commit_budget(code_analytique: str, amount: float):
	"""Increment committed_amount on SDR Budget and recompute available_amount.

	Assumes SDR Budget has fields: montant (total), committed_amount, available_amount.
	"""
	if not code_analytique:
		return
	try:
		bud = frappe.get_doc("SDR Budget", code_analytique)
	except frappe.DoesNotExistError:
		return
	committed = flt(getattr(bud, "committed_amount", 0)) + flt(amount)
	bud.committed_amount = committed
	total = flt(getattr(bud, "montant", 0))
	bud.available_amount = total - committed
	bud.db_update()


def _rollback_budget(code_analytique: str, amount: float):
	"""Reverse (decrement) committed_amount by 'amount'.

	Prevents negative committed; recompute available.
	"""
	if not code_analytique or not amount:
		return
	try:
		bud = frappe.get_doc("SDR Budget", code_analytique)
	except frappe.DoesNotExistError:
		return
	committed = flt(getattr(bud, "committed_amount", 0)) - flt(amount)
	if committed < 0:
		committed = 0
	bud.committed_amount = committed
	total = flt(getattr(bud, "montant", 0))
	bud.available_amount = total - committed
	bud.db_update()


def engage_budgets_for_po(doc, method=None):
	"""Engage (commit) budgets for a draft or submitted Purchase Order by summing line amounts.

	This can be called after importing DA lines and on submit to ensure sync.
	Idempotence: we do not track reversals here; simplistic accumulate model.
	"""
	for item in doc.get("items") or []:
		code = getattr(item, "code_analytique", None)
		amount = flt(getattr(item, "amount", 0))
		if code and amount:
			_commit_budget(code, amount)


def rollback_budgets_for_po(doc, method=None):
	"""Rollback committed budgets when a PO is cancelled."""
	for item in doc.get("items") or []:
		code = getattr(item, "code_analytique", None)
	amount = flt(getattr(item, "amount", 0))
	if code and amount:
		_rollback_budget(code, amount)


def _map_by_po_item(doc):
	"""Build an index of Purchase Order Item by name for fast lookup.

	Supports both single and multiple Purchase Orders referenced by PR items.
	"""
	from frappe.utils import flt
	index: Dict[str, Dict] = {}
	po_cache: Dict[str, any] = {}
	for it in getattr(doc, "items", []) or []:
		po = getattr(it, "purchase_order", None) or getattr(doc, "purchase_order", None)
		poi = getattr(it, "po_detail", None) or getattr(it, "purchase_order_item", None)
		if not po or not poi or poi in index:
			continue
		if po not in po_cache:
			try:
				po_cache[po] = frappe.get_doc("Purchase Order", po)
			except Exception:
				po_cache[po] = None
		po_doc = po_cache.get(po)
		if not po_doc:
			continue
		for po_it in po_doc.get("items") or []:
			name = getattr(po_it, "name", None)
			if name:
				index[name] = po_it
	return index
def sync_pr_items_from_po(doc, method=None):
	"""Enrich Purchase Receipt Items with custom fields from linked Purchase Order Items.

	Minimal and safe: executed after the standard map; only copies custom fields and
	doesn't override core quantities, warehouses, prices, or dates.

	Fields copied (if present on PO Item):
	- code_analytique -> set on PR Item
	- description (custom) -> set on PR Item's item_name, if item_name currently equals
	  the budget code or placeholder label.
	- Ensures valid item_code for budget lines
	"""
	if not getattr(doc, "items", None):
		return

	# Build a lookup of PO Item rows by name once
	poi_index = _map_by_po_item(doc)
	if not poi_index:
		return

	for it in doc.items:
		po_item_name = getattr(it, "po_detail", None) or getattr(it, "purchase_order_item", None)
		if not po_item_name:
			continue
		src = poi_index.get(po_item_name)
		if not src:
			continue

		# Copy code_analytique if defined on PO Item
		code = getattr(src, "code_analytique", None)
		if code:
			it.code_analytique = code

		# Handle invalid item codes for budget lines
		if code and (not it.item_code or not frappe.db.exists('Item', it.item_code)):
			# Ensure BUDGET-LINE item exists
			ensure_budget_placeholder_item()
			it.item_code = 'BUDGET-LINE'
			if not it.stock_uom:
				it.stock_uom = 'Nos'
			if not it.uom:
				it.uom = 'Nos'

		# Copy a more user-friendly description if available, without breaking standard naming
		desc = getattr(src, "item_name", None)
		# Prefer explicit custom description field when present
		if hasattr(src, "description") and getattr(src, "description"):
			desc = getattr(src, "description")

		# If PR item looks like a placeholder, improve the label; otherwise leave it intact
		if desc:
			current_name = getattr(it, "item_name", "") or ""
			placeholder_markers = {"BUDGET-LINE", code or ""}
			if current_name.strip() in placeholder_markers:
				it.item_name = desc

			# If PR item looks like a placeholder, improve the label; otherwise leave it intact
			if desc:
				current_name = getattr(it, "item_name", "") or ""
				placeholder_markers = {"BUDGET-LINE", code or ""}
				if current_name.strip() in placeholder_markers:
					it.item_name = desc


	@frappe.whitelist()
	def make_purchase_receipt_override(source_name, target_doc=None, args=None):
		"""Clean override of ERPNext PO->PR mapping used by the 'Get Items' button.

		Strategy:
		- Delegate to the core ERPNext mapping function to produce the PR document.
		- Post-process only the mapped child items to inject our custom fields:
		  * copy code_analytique
		  * set item_name from description when current item_name is a placeholder
		- Do not alter quantities, warehouses, rate, taxes, or dates.
		"""
		# 1) Call core implementation to build base PR
		core = frappe.get_attr("erpnext.buying.doctype.purchase_order.purchase_order.make_purchase_receipt")
		pr = core(source_name, target_doc=target_doc, args=args)

		# 2) Build a fast index of source PO Items by name
		if not pr or not getattr(pr, "items", None):
			return pr

		try:
			po = frappe.get_doc("Purchase Order", source_name)
		except Exception:
			return pr

		src_by_name = {getattr(it, "name", None): it for it in (po.get("items") or []) if getattr(it, "name", None)}

		# 3) Apply minimal enrichment to PR items
		for it in pr.items:
			po_item_name = getattr(it, "purchase_order_item", None) or getattr(it, "po_detail", None)
			if not po_item_name:
				continue
			src = src_by_name.get(po_item_name)
			if not src:
				continue

			code = getattr(src, "code_analytique", None)
			if code:
				it.code_analytique = code

			# Prefer custom description if present, else fall back to item_name on PO line
			desc = getattr(src, "description", None) or getattr(src, "item_name", None)
			if desc:
				current_name = getattr(it, "item_name", "") or ""
				placeholders = {"BUDGET-LINE", (code or "")}
				if current_name.strip() in placeholders:
					it.item_name = desc

		return pr


def update_sdr_budget_available(doc, method=None):  # doc_events: before_insert, validate
	"""Ensure available_amount = montant - committed_amount (ou = montant à la création).

	Règles:
	- committed_amount null => 0
	- montant null => 0
	- Si committed > montant: erreur (cohérence)
	- available_amount recalculé systématiquement (même champs read_only côté UI)
	"""
	committed = flt(getattr(doc, "committed_amount", 0))
	total = flt(getattr(doc, "montant", 0))
	if committed < 0:
		committed = 0
	if committed > total:
		frappe.throw(_(f"Montant engagé ({committed}) dépasse le montant total ({total})."))
	doc.committed_amount = committed
	doc.available_amount = total - committed

@frappe.whitelist()
def engage_po_budgets(purchase_order: str):
	"""Wrapper function to maintain backward compatibility for whitelisted calls."""
	doc = frappe.get_doc("Purchase Order", purchase_order)
	engage_budgets_for_po(doc)
	return {"status": "ok"}


@frappe.whitelist()
def get_budget_placeholder_item():
	"""Return structured info for a generic non-stock Item used for budget-only PO lines.

	Best practice adjustments:
	- Pick an existing UOM: prefer one of ['Nos','Unit','Unité','PCE','Each'] else first UOM found.
	- Create item once with code 'BUDGET-LINE'.
	- Return dict { item_code, stock_uom } instead of raw string for better client logic.
	"""
	placeholder_code = 'BUDGET-LINE'
	# Determine suitable UOM
	preferred = ['Nos', 'Unit', 'Unité', 'PCE', 'Each']
	chosen_uom = None
	for cand in preferred:
		if frappe.db.exists('UOM', cand):
			chosen_uom = cand
			break
	if not chosen_uom:
		chosen_uom = frappe.db.get_value('UOM', {}, 'name') or 'Nos'

	if not frappe.db.exists('Item', placeholder_code):
		item_group = 'All Item Groups'
		if not frappe.db.exists('Item Group', item_group):
			first_group = frappe.db.get_value('Item Group', {}, 'name')
			if first_group:
				item_group = first_group or 'All Item Groups'
		doc = frappe.get_doc({
			'doctype': 'Item',
			'item_code': placeholder_code,
			'item_name': 'Budget Placeholder',
			'item_group': item_group,
			'include_item_in_manufacturing': 0,
			'is_stock_item': 0,
			'allow_alternative_item': 0,
			'has_batch_no': 0,
			'has_serial_no': 0,
			'has_variants': 0,
			'stock_uom': chosen_uom
		})
		doc.insert(ignore_permissions=True)
		return {'item_code': placeholder_code, 'stock_uom': chosen_uom}

	# If already exists, read its stock_uom
	stock_uom = frappe.db.get_value('Item', placeholder_code, 'stock_uom') or chosen_uom
	return {'item_code': placeholder_code, 'stock_uom': stock_uom}


def validate_purchase_order_item(doc, method):
	"""Custom validation for Purchase Order Item to bypass Item validation for budget lines."""
	for item in doc.items:
		# If item has code_analytique but no valid item_code, set a simple placeholder
		if item.code_analytique and (not item.item_code or item.item_code in [None, '', 'None']):
			# Set simple placeholder - no external dependencies
			item.item_code = 'BUDGET-LINE'
			
			# Ensure UOM is valid - use simple defaults
			if not item.uom:
				item.uom = 'Nos'
			if not item.stock_uom:
				item.stock_uom = 'Nos'
			
			# Ensure the BUDGET-LINE item exists
			if not frappe.db.exists('Item', 'BUDGET-LINE'):
				frappe.get_doc({
					'doctype': 'Item',
					'item_code': 'BUDGET-LINE',
					'item_name': 'Budget Placeholder',
					'item_group': 'All Item Groups',
					'stock_uom': 'Nos',
					'is_stock_item': 0
				}).insert(ignore_permissions=True)


@frappe.whitelist()
@frappe.validate_and_sanitize_search_inputs
def get_default_supplier_query(doctype, txt, searchfield, start, page_len, filters):
	"""Safe override of ERPNext Material Request supplier link query.

	Fixes edge case when Material Request has no items, which causes SQL `IN ()` error.
	Behavior:
	- If MR has items, delegate to core method for full behavior.
	- If MR has no items, return an empty result set safely.
	"""
	mr_name = None
	if isinstance(filters, dict):
		mr_name = filters.get("doc")
	# Defensive: filters can be a JSON string in some calls
	if not mr_name and isinstance(filters, str):
		try:
			data = frappe.parse_json(filters)
			mr_name = data.get("doc") if isinstance(data, dict) else None
		except Exception:
			mr_name = None

	if not mr_name:
		return []

	try:
		doc = frappe.get_doc("Material Request", mr_name)
	except Exception:
		return []

	# If there are no items on the standard child table, avoid calling core (would generate IN ())
	if not getattr(doc, "items", None):
		return []

	# Delegate to core implementation for normal path
	core = frappe.get_attr(
		"erpnext.stock.doctype.material_request.material_request.get_default_supplier_query"
	)
	return core(doctype, txt, searchfield, start, page_len, filters)


# ========================================
# Purchase Receipt Support Functions
# ========================================

def ensure_budget_placeholder_item():
	"""Ensure BUDGET-LINE item exists for budget-only purchase transactions."""
	if not frappe.db.exists('Item', 'BUDGET-LINE'):
		# Get a valid item group
		item_group = 'All Item Groups'
		if not frappe.db.exists('Item Group', item_group):
			# Try to find any item group
			groups = frappe.db.get_list('Item Group', limit=1)
			if groups:
				item_group = groups[0].name
			else:
				# Fallback to any group
				item_group = 'Services'
		
		# Get a valid UOM
		uom = 'Nos'
		if not frappe.db.exists('UOM', uom):
			# Try alternative UOMs
			for alt_uom in ['Unit', 'Unité', 'PCE', 'Each']:
				if frappe.db.exists('UOM', alt_uom):
					uom = alt_uom
					break
			else:
				# Get any UOM
				existing_uom = frappe.db.get_value('UOM', {}, 'name')
				if existing_uom:
					uom = existing_uom
		
		# Create the placeholder item
		try:
			item_doc = frappe.get_doc({
				'doctype': 'Item',
				'item_code': 'BUDGET-LINE',
				'item_name': 'Budget Placeholder',
				'item_group': item_group,
				'stock_uom': uom,
				'is_stock_item': 0,
				'include_item_in_manufacturing': 0,
				'allow_alternative_item': 0,
				'has_batch_no': 0,
				'has_serial_no': 0,
				'has_variants': 0
			})
			item_doc.insert(ignore_permissions=True)
			frappe.db.commit()
		except Exception as e:
			frappe.log_error(f"Failed to create BUDGET-LINE item: {e}")


@frappe.whitelist()
def make_purchase_receipt_override(source_name, target_doc=None, args=None):
	"""Override for Purchase Order → Purchase Receipt mapping.
	
	This function replaces the standard ERPNext mapping to handle budget line items properly.
	It ensures that Purchase Receipt items with budget codes get valid item_codes.
	"""
	# First, call the standard ERPNext function to get base mapping
	try:
		# Import the original function
		from erpnext.buying.doctype.purchase_order.purchase_order import make_purchase_receipt
		
		# Call original function
		pr_doc = make_purchase_receipt(source_name, target_doc, args)
		
		if not pr_doc or not getattr(pr_doc, 'items', None):
			return pr_doc
			
		# Get the source Purchase Order for reference
		try:
			po_doc = frappe.get_doc('Purchase Order', source_name)
		except Exception:
			return pr_doc
			
		# Build mapping of PO items by name for lookup
		po_items_map = {}
		for po_item in po_doc.get('items') or []:
			if getattr(po_item, 'name', None):
				po_items_map[po_item.name] = po_item
		
		# Process each Purchase Receipt item
		for pr_item in pr_doc.items:
			po_item_name = getattr(pr_item, 'purchase_order_item', None) or getattr(pr_item, 'po_detail', None)
			if not po_item_name or po_item_name not in po_items_map:
				continue
				
			po_item = po_items_map[po_item_name]
			code_analytique = getattr(po_item, 'code_analytique', None)
			
			# If this is a budget line item, ensure proper setup
			if code_analytique:
				# Copy the budget code
				pr_item.code_analytique = code_analytique
				
				# Check if item_code is valid, if not, use placeholder
				if not pr_item.item_code or not frappe.db.exists('Item', pr_item.item_code):
					ensure_budget_placeholder_item()
					pr_item.item_code = 'BUDGET-LINE'
					
					# Ensure UOM is set
					if not pr_item.stock_uom:
						pr_item.stock_uom = 'Nos'
					if not pr_item.uom:
						pr_item.uom = 'Nos'
				
				# Improve description if available
				description = getattr(po_item, 'description', None) or getattr(po_item, 'item_name', None)
				if description and (not pr_item.item_name or pr_item.item_name in ['BUDGET-LINE', code_analytique]):
					pr_item.item_name = description
		
		return pr_doc
		
	except Exception as e:
		frappe.log_error(f"Error in make_purchase_receipt_override: {e}")
		# Fallback to standard function if our override fails
		from erpnext.buying.doctype.purchase_order.purchase_order import make_purchase_receipt
		return make_purchase_receipt(source_name, target_doc, args)


def validate_purchase_receipt_items(doc, method=None):
	"""Validate and fix invalid item codes in Purchase Receipt before save.
	
	This function ensures that any invalid item_code gets replaced with BUDGET-LINE
	to prevent the AttributeError in price calculation.
	"""
	if not getattr(doc, 'items', None):
		return
		
	for item in doc.items:
		# Check if item_code exists, if not replace with BUDGET-LINE
		if item.item_code and not frappe.db.exists('Item', item.item_code):
			# Ensure BUDGET-LINE exists
			ensure_budget_placeholder_item()
			
			# Store original invalid code for reference
			original_code = item.item_code
			
			# Replace with valid placeholder
			item.item_code = 'BUDGET-LINE'
			
			# If no proper item name, use the original code as description
			if not item.item_name or item.item_name == original_code:
				item.item_name = f"Budget Line - {original_code}"
			
			# Ensure valid UOM
			if not item.stock_uom:
				item.stock_uom = 'Nos'
			if not item.uom:
				item.uom = 'Nos'
				
			# Store the original code as code_analytique if not already set
			if not getattr(item, 'code_analytique', None):
				item.code_analytique = original_code
	"""Validate Purchase Receipt items and handle budget codes properly."""
	if not getattr(doc, 'items', None):
		return
		
	for item in doc.items:
		code_analytique = getattr(item, 'code_analytique', None)
		
		# If item has code_analytique but invalid item_code, fix it
		if code_analytique and (not item.item_code or not frappe.db.exists('Item', item.item_code)):
			ensure_budget_placeholder_item()
			item.item_code = 'BUDGET-LINE'
			
			# Ensure UOM is valid
			if not item.stock_uom:
				item.stock_uom = 'Nos'
			if not item.uom:
				item.uom = 'Nos'
				
			# Set a meaningful name if not already set
			if not item.item_name or item.item_name == item.item_code:
				item.item_name = f"Budget Line - {code_analytique}"


def sync_purchase_receipt_from_po(doc, method=None):
	"""Sync custom fields from Purchase Order to Purchase Receipt after standard mapping."""
	if not getattr(doc, 'items', None):
		return
		
	# Build cache of Purchase Orders referenced by this PR
	po_cache = {}
	
	for pr_item in doc.items:
		# Get Purchase Order reference
		po_name = getattr(pr_item, 'purchase_order', None) or getattr(doc, 'purchase_order', None)
		po_item_name = getattr(pr_item, 'purchase_order_item', None) or getattr(pr_item, 'po_detail', None)
		
		if not po_name or not po_item_name:
			continue
			
		# Load PO if not in cache
		if po_name not in po_cache:
			try:
				po_cache[po_name] = frappe.get_doc('Purchase Order', po_name)
			except Exception:
				po_cache[po_name] = None
				
		po_doc = po_cache.get(po_name)
		if not po_doc:
			continue
			
		# Find matching PO item
		po_item = None
		for item in po_doc.get('items') or []:
			if getattr(item, 'name', None) == po_item_name:
				po_item = item
				break
				
		if not po_item:
			continue
			
		# Copy custom fields
		code_analytique = getattr(po_item, 'code_analytique', None)
		if code_analytique:
			pr_item.code_analytique = code_analytique

